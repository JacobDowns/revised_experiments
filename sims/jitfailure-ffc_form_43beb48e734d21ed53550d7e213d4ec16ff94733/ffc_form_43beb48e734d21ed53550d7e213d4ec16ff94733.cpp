// This code conforms with the UFC specification version 2016.2.0
// and was automatically generated by FFC version 2016.2.0.
// 
// This code was generated with the following parameters:
// 
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  False
//   form_postfix:                   False
//   format:                         'ufc'
//   max_signature_length:           0
//   no-evaluate_basis_derivatives:  True
//   optimize:                       False
//   precision:                      100
//   quadrature_degree:              -1
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False

#include "ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733.h"

// Based on https://gcc.gnu.org/wiki/Visibility
#if defined _WIN32 || defined __CYGWIN__
    #ifdef __GNUC__
        #define DLL_EXPORT __attribute__ ((dllexport))
    #else
        #define DLL_EXPORT __declspec(dllexport)
    #endif
#else
    #define DLL_EXPORT __attribute__ ((visibility ("default")))
#endif

ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1::ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1() : ufc::exterior_facet_integral()
{
    
}

ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1::~ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1()
{
    
}

const std::vector<bool> & ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1::enabled_coefficients() const
{
    static const std::vector<bool> enabled({true, true, true, true});
    return enabled;
}

void ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1::tabulate_tensor(double * A,
                                    const double * const * w,
                                    const double * coordinate_dofs,
                                    std::size_t facet,
                                    int cell_orientation) const
{
    // This function was generated using 'quadrature' representation
    // with the following integrals metadata:
    // 
    //   num_cells:         None
    //   quadrature_degree: 2
    //   quadrature_rule:   'default'
    //   representation:    'quadrature'
    // 
    // and the following integral 0 metadata:
    // 
    //   estimated_polynomial_degree: 2
    //   quadrature_degree:           2
    //   quadrature_rule:             'default'
    //   representation:              'quadrature'
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, coordinate_dofs);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = coordinate_dofs[2*v1 + 0] - coordinate_dofs[2*v0 + 0];
    const double dx1 = coordinate_dofs[2*v1 + 1] - coordinate_dofs[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    // Compute facet normals from the facet scale factor constants
    
    // Facet area
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W2[2] = {0.5, 0.5};
    // Quadrature points on the UFC reference element: (0.2113248654051871344705659794271923601627349853515625), (0.7886751345948128655294340205728076398372650146484375)
    
    // Values of basis functions at quadrature points.
    static const double FE0_f0[2][3] = \
    {{-2.0816681711721685132943093776702880859375e-17, 0.7886751345948128655294340205728076398372650146484375, 0.2113248654051871344705659794271923601627349853515625},
    {5.5511151231257827021181583404541015625e-17, 0.211324865405187189981717210685019381344318389892578125, 0.7886751345948128655294340205728076398372650146484375}};
    
    static const double FE0_f0_D01[2][3] = \
    {{-1.00000000000000088817841970012523233890533447265625, 8.8817841970012523233890533447265625e-16, 1.0},
    {-1.00000000000000088817841970012523233890533447265625, 8.8817841970012523233890533447265625e-16, 1.0}};
    
    static const double FE0_f0_D10[2][3] = \
    {{-0.99999999999999877875467291232780553400516510009765625, 0.99999999999999877875467291232780553400516510009765625, 0.0},
    {-0.99999999999999877875467291232780553400516510009765625, 0.99999999999999877875467291232780553400516510009765625, 0.0}};
    
    static const double FE0_f1[2][3] = \
    {{0.7886751345948128655294340205728076398372650146484375, -2.0816681711721685132943093776702880859375e-17, 0.2113248654051871344705659794271923601627349853515625},
    {0.211324865405187189981717210685019381344318389892578125, 5.5511151231257827021181583404541015625e-17, 0.7886751345948128655294340205728076398372650146484375}};
    
    static const double FE0_f2[2][3] = \
    {{0.7886751345948128655294340205728076398372650146484375, 0.2113248654051871622261415950561058707535266876220703125, 0.0},
    {0.2113248654051871622261415950561058707535266876220703125, 0.7886751345948128655294340205728076398372650146484375, 0.0}};
    
    static const double FE1_f0[2][1] = \
    {{1.0},
    {1.0}};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', False), ('ignore ones', False), ('ignore zero tables', False), ('optimisation', False), ('remove zero terms', False)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 156
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 156
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        double F3 = 0.0;
        double F4 = 0.0;
        
        // Total number of operations to compute function values = 2
        for (unsigned int r = 0; r < 1; r++)
        {
          F4 += FE1_f0[ip][0]*w[3][0];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 24
        for (unsigned int r = 0; r < 3; r++)
        {
          F0 += FE0_f0_D10[ip][r]*w[0][r];
          F1 += FE0_f0_D01[ip][r]*w[0][r];
          F2 += FE0_f0[ip][r]*w[2][r];
          F3 += FE0_f0[ip][r]*w[1][r];
        } // end loop over 'r'
        
        // Number of operations for primary indices: 52
        // Number of operations to compute entry: 52
        A[0] += ((((K[0]*F0 + K[2]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_00 + (((K[1]*F0 + K[3]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_01)*W2[ip]*det;
      } // end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 156
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 156
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        double F3 = 0.0;
        double F4 = 0.0;
        
        // Total number of operations to compute function values = 2
        for (unsigned int r = 0; r < 1; r++)
        {
          F4 += FE1_f0[ip][0]*w[3][0];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 24
        for (unsigned int r = 0; r < 3; r++)
        {
          F0 += FE0_f0_D10[ip][r]*w[0][r];
          F1 += FE0_f0_D01[ip][r]*w[0][r];
          F2 += FE0_f1[ip][r]*w[2][r];
          F3 += FE0_f1[ip][r]*w[1][r];
        } // end loop over 'r'
        
        // Number of operations for primary indices: 52
        // Number of operations to compute entry: 52
        A[0] += ((((K[0]*F0 + K[2]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_00 + (((K[1]*F0 + K[3]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_01)*W2[ip]*det;
      } // end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 156
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 156
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        double F3 = 0.0;
        double F4 = 0.0;
        
        // Total number of operations to compute function values = 2
        for (unsigned int r = 0; r < 1; r++)
        {
          F4 += FE1_f0[ip][0]*w[3][0];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 24
        for (unsigned int r = 0; r < 3; r++)
        {
          F0 += FE0_f0_D10[ip][r]*w[0][r];
          F1 += FE0_f0_D01[ip][r]*w[0][r];
          F2 += FE0_f2[ip][r]*w[2][r];
          F3 += FE0_f2[ip][r]*w[1][r];
        } // end loop over 'r'
        
        // Number of operations for primary indices: 52
        // Number of operations to compute entry: 52
        A[0] += ((((K[0]*F0 + K[2]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_00 + (((K[1]*F0 + K[3]*F1))*((((-1.0)*F2)*std::pow(F3, 1.25))*(std::pow(((((K[0]*F0 + K[2]*F1))*((K[0]*F0 + K[2]*F1)) + ((K[1]*F0 + K[3]*F1))*((K[1]*F0 + K[3]*F1))) + F4), -0.25))))*n_01)*W2[ip]*det;
      } // end loop over 'ip'
        break;
      }
    }
    
}

extern "C" DLL_EXPORT ufc::exterior_facet_integral * create_ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1()
{
  return new ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1();
}


ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main() : ufc::form()
{
    // Do nothing
}

ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::~ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main()
{
    // Do nothing
}

const char * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::signature() const
{
    return "ba21eaefb2928fc5ace2b1a97a32ce46d5a7c5e7419bd42cc8837192a00cd32769ba8eeb03adf455a4b4b34c8d1a59d59e122cf4cb01bfd2afcd3721b879d44c";
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::rank() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::num_coefficients() const
{
    return 4;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::original_coefficient_position(std::size_t i) const
{
    static const std::vector<std::size_t> position({0, 1, 2, 3});
    return position[i];
}

ufc::finite_element * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_coordinate_finite_element() const
{
    return create_ffc_element_639eb2b6364c832bf001f46acc76381a1eeb07fa_finite_element_main();
}

ufc::dofmap * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_coordinate_dofmap() const
{
    return create_ffc_element_639eb2b6364c832bf001f46acc76381a1eeb07fa_dofmap_main();
}

ufc::coordinate_mapping * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_coordinate_mapping() const
{
    return nullptr;
}

ufc::finite_element * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_finite_element(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_finite_element_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_finite_element_main();
        break;
      }
    case 2:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_finite_element_main();
        break;
      }
    case 3:
      {
        return create_ffc_element_4129196f8130ba84efe6cd7c83c851a8ca47d028_finite_element_main();
        break;
      }
    }
    
    return 0;
}

ufc::dofmap * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_dofmap(std::size_t i) const
{
    switch (i)
    {
    case 0:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_dofmap_main();
        break;
      }
    case 1:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_dofmap_main();
        break;
      }
    case 2:
      {
        return create_ffc_element_06b84d8b0c4ba9118bfe4a715078a884675bdf94_dofmap_main();
        break;
      }
    case 3:
      {
        return create_ffc_element_4129196f8130ba84efe6cd7c83c851a8ca47d028_dofmap_main();
        break;
      }
    }
    
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_cell_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_exterior_facet_subdomain_id() const
{
    return 2;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_interior_facet_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_vertex_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_custom_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_cutcell_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_interface_subdomain_id() const
{
    return 0;
}

std::size_t ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::max_overlap_subdomain_id() const
{
    return 0;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_cell_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_exterior_facet_integrals() const
{
    return true;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_interior_facet_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_vertex_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_custom_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_cutcell_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_interface_integrals() const
{
    return false;
}

bool ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::has_overlap_integrals() const
{
    return false;
}

ufc::cell_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_cell_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::exterior_facet_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_exterior_facet_integral(std::size_t subdomain_id) const
{
    switch (subdomain_id)
    {
    case 1:
      {
        return new ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_exterior_facet_integral_main_1();
        break;
      }
    }
    
    return 0;
}

ufc::interior_facet_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_interior_facet_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::vertex_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_vertex_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::custom_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_custom_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_cutcell_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::interface_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_interface_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::overlap_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_overlap_integral(std::size_t subdomain_id) const
{
    return 0;
}

ufc::cell_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_cell_integral() const
{
    return 0;
}

ufc::exterior_facet_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_exterior_facet_integral() const
{
    return 0;
}

ufc::interior_facet_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_interior_facet_integral() const
{
    return 0;
}

ufc::vertex_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_vertex_integral() const
{
    return 0;
}

ufc::custom_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_custom_integral() const
{
    return 0;
}

ufc::cutcell_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_cutcell_integral() const
{
    return 0;
}

ufc::interface_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_interface_integral() const
{
    return 0;
}

ufc::overlap_integral * ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main::create_default_overlap_integral() const
{
    return 0;
}

extern "C" DLL_EXPORT ufc::form * create_ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main()
{
  return new ffc_form_43beb48e734d21ed53550d7e213d4ec16ff94733_form_main();
}

